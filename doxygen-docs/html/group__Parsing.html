<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSS - S3 Toolkit: Parsing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SSS - S3 Toolkit<span id="projectnumber">&#160;0.9.4</span>
   </div>
   <div id="projectbrief">S3 client library and applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__Parsing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Parsing</div></div>
</div><!--header-->
<div class="contents">

<p>Response parser function for XML body and HTTP headers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXMLOStream.html">XMLOStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XMLGenerator. Use methods or overloaded subscript operator to insert data into XML tree.  <a href="classXMLOStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXMLIStream.html">XMLIStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML parser, returns array of text elements with the same parent path or an array of parsed XML sub trees.  <a href="classXMLIStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacf486071ed8bd3e6f76fe9ee23639bde"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gacf486071ed8bd3e6f76fe9ee23639bde">sss::XMLTag</a> (const std::string &amp;xml, const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacf486071ed8bd3e6f76fe9ee23639bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return content of XML tag.  <br /></td></tr>
<tr class="separator:gacf486071ed8bd3e6f76fe9ee23639bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6c22034ff7357c481d51660b33df17"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gabb6c22034ff7357c481d51660b33df17">sss::XMLTags</a> (const std::string &amp;xml, const std::string &amp;tag)</td></tr>
<tr class="memdesc:gabb6c22034ff7357c481d51660b33df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return content of all XML tags matching word.  <br /></td></tr>
<tr class="separator:gabb6c22034ff7357c481d51660b33df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddaff0aa8a7f3ad2e60f73e16fc3ce11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaddaff0aa8a7f3ad2e60f73e16fc3ce11">sss::XMLTagPath</a> (const std::string &amp;xml, const std::string &amp;path)</td></tr>
<tr class="memdesc:gaddaff0aa8a7f3ad2e60f73e16fc3ce11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return content of XML tag matching hierchical path.  <br /></td></tr>
<tr class="separator:gaddaff0aa8a7f3ad2e60f73e16fc3ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020103649cb1ae997e00f10d72ad6acd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga020103649cb1ae997e00f10d72ad6acd">sss::HTTPHeader</a> (const std::string &amp;headers, const std::string &amp;header)</td></tr>
<tr class="memdesc:ga020103649cb1ae997e00f10d72ad6acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return HTTP header.  <br /></td></tr>
<tr class="separator:ga020103649cb1ae997e00f10d72ad6acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9233a3e8a097605d9168bf860e93e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Types.html#ga715f63ab4ed0dae42d3337ff0a29d5d3">Headers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaca9233a3e8a097605d9168bf860e93e5">sss::HTTPHeaders</a> (const std::string &amp;headers)</td></tr>
<tr class="memdesc:gaca9233a3e8a097605d9168bf860e93e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return HTTP headers as key-value pairs.  <br /></td></tr>
<tr class="separator:gaca9233a3e8a097605d9168bf860e93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e0b5f396ca92caa59f6870807789b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Types.html#ga769a4a4cc1bcab19498096e1b85e7e69">MetaDataMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga95e0b5f396ca92caa59f6870807789b6">sss::MetaDataHeaders</a> (const std::string &amp;headers)</td></tr>
<tr class="memdesc:ga95e0b5f396ca92caa59f6870807789b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and return <code>x-amz-meta-*</code> headers.  <br /></td></tr>
<tr class="separator:ga95e0b5f396ca92caa59f6870807789b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31b67eec4fc7c00367031debd298fd8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gab31b67eec4fc7c00367031debd298fd8">sss::TrimETag</a> (const std::string &amp;etag)</td></tr>
<tr class="memdesc:gab31b67eec4fc7c00367031debd298fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract ETag string from returned etag text.  <br /></td></tr>
<tr class="separator:gab31b67eec4fc7c00367031debd298fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663d4f6452842fce3694964ec0d38bd1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga663d4f6452842fce3694964ec0d38bd1">FindElementText</a> (const std::string &amp;xml, const std::string &amp;element)</td></tr>
<tr class="memdesc:ga663d4f6452842fce3694964ec0d38bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return text inside XML tags.  <br /></td></tr>
<tr class="separator:ga663d4f6452842fce3694964ec0d38bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf271316bde50a40dba0a85b94fe0f00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gacf271316bde50a40dba0a85b94fe0f00">ParseXMLPath</a> (const std::string &amp;xml, const std::string &amp;path)</td></tr>
<tr class="memdesc:gacf271316bde50a40dba0a85b94fe0f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract text under XML path.  <br /></td></tr>
<tr class="separator:gacf271316bde50a40dba0a85b94fe0f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffdbf75ebbc4755e1ded379546865d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga5ffdbf75ebbc4755e1ded379546865d5">ParseXMLMultiPathText</a> (const std::string &amp;xml, const std::string &amp;prefixPpath, const std::string &amp;suffixPath)</td></tr>
<tr class="memdesc:ga5ffdbf75ebbc4755e1ded379546865d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilevel parsing function: return all elements matching path under prefix.  <br /></td></tr>
<tr class="separator:ga5ffdbf75ebbc4755e1ded379546865d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010b2c94ea150c9c57b9a42cc03ba414"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unordered_map&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga010b2c94ea150c9c57b9a42cc03ba414">RecordList</a> (const std::string &amp;prefix, const std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; &amp;domMap)</td></tr>
<tr class="memdesc:ga010b2c94ea150c9c57b9a42cc03ba414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract records from DOM Map.  <br /></td></tr>
<tr class="separator:ga010b2c94ea150c9c57b9a42cc03ba414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71fc992a1e6c4c8a220fd916e08acb79"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga71fc992a1e6c4c8a220fd916e08acb79">ParseXMLPathElementsText</a> (const std::string &amp;xml, const std::string &amp;path)</td></tr>
<tr class="memdesc:ga71fc992a1e6c4c8a220fd916e08acb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all elements at location grouped by element name.  <br /></td></tr>
<tr class="separator:ga71fc992a1e6c4c8a220fd916e08acb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf7799880288a51a684f1f3947146a4"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gacaf7799880288a51a684f1f3947146a4">DOMToDict</a> (const std::string &amp;xml)</td></tr>
<tr class="memdesc:gacaf7799880288a51a684f1f3947146a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert XML text to {path, text element array} map. <b>Input</b>.  <br /></td></tr>
<tr class="separator:gacaf7799880288a51a684f1f3947146a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82f61f7f4a30fb27a566a889fb3abc7"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gae82f61f7f4a30fb27a566a889fb3abc7">ExtractSubPaths</a> (const std::string &amp;prefix, const std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; &amp;domMap)</td></tr>
<tr class="memdesc:gae82f61f7f4a30fb27a566a889fb3abc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return map of {subpaths with same prefix, {list of text elements under subpaths}}.  <br /></td></tr>
<tr class="separator:gae82f61f7f4a30fb27a566a889fb3abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c224486b4f631683d4f6bc22a54620"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga85c224486b4f631683d4f6bc22a54620">XMLToText</a> (const tinyxml2::XMLDocument &amp;doc, bool header=true, char eol_='\n', int indent=2, std::unordered_map&lt; std::string, std::string &gt; kv={})</td></tr>
<tr class="memdesc:ga85c224486b4f631683d4f6bc22a54620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform DOM into text, replacing matching keywords with values specified in {keyword =&gt; value} map.  <br /></td></tr>
<tr class="separator:ga85c224486b4f631683d4f6bc22a54620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf404376740b21c013c69ec73204676e8"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaf404376740b21c013c69ec73204676e8">CreatePath</a> (tinyxml2::XMLElement *n, const std::string &amp;path, const std::string &amp;text=&quot;&quot;)</td></tr>
<tr class="memdesc:gaf404376740b21c013c69ec73204676e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create XML tree from path format and place it under passed element. I.e. from {"/tag1/tag2", "text"} to "&lt;tag1&gt;&lt;tag2&gt;text&lt;/tag2&gt;&lt;/tag1&gt;".  <br /></td></tr>
<tr class="separator:gaf404376740b21c013c69ec73204676e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e2fb61e0f87aba9fa1baf5d1325971"><td class="memItemLeft" align="right" valign="top"><a id="ga87e2fb61e0f87aba9fa1baf5d1325971" name="ga87e2fb61e0f87aba9fa1baf5d1325971"></a>
tinyxml2::XMLElement *&#160;</td><td class="memItemRight" valign="bottom"><b>CreatePath</b> (tinyxml2::XMLDocument &amp;doc, const std::string &amp;path, const std::string &amp;text=&quot;&quot;)</td></tr>
<tr class="memdesc:ga87e2fb61e0f87aba9fa1baf5d1325971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create XML tree from path format and place inside document instance. <br /></td></tr>
<tr class="separator:ga87e2fb61e0f87aba9fa1baf5d1325971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceed1c630628211fe28e59763878d374"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#gaceed1c630628211fe28e59763878d374">CreatePaths</a> (tinyxml2::XMLElement *n, const std::string &amp;path, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;paths)</td></tr>
<tr class="memdesc:gaceed1c630628211fe28e59763878d374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multiple XML trees under element. Invokes CreatePath multiple times passing {path, text} value at each invocation.  <br /></td></tr>
<tr class="separator:gaceed1c630628211fe28e59763878d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568ec520d4ecebc8e60540a17888fc0d"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga568ec520d4ecebc8e60540a17888fc0d">CreatePaths</a> (tinyxml2::XMLDocument &amp;doc, const std::string &amp;path, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;paths)</td></tr>
<tr class="memdesc:ga568ec520d4ecebc8e60540a17888fc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create multiple XML trees inside <code>tynyxml2</code> XML document. Invokes CreatePath multiple times passing {path, text} value at each invocation.  <br /></td></tr>
<tr class="separator:ga568ec520d4ecebc8e60540a17888fc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a75f823e8de2f3d1b501bab6b6510f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Parsing.html#ga8a75f823e8de2f3d1b501bab6b6510f5">Get</a> (const XMLRecord &amp;r, const std::string &amp;path)</td></tr>
<tr class="separator:ga8a75f823e8de2f3d1b501bab6b6510f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Response parser function for XML body and HTTP headers. </p>
<p>High level XML parsing functions using filepath like input.</p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf404376740b21c013c69ec73204676e8" name="gaf404376740b21c013c69ec73204676e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf404376740b21c013c69ec73204676e8">&#9670;&#160;</a></span>CreatePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLElement * CreatePath </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create XML tree from path format and place it under passed element. I.e. from {"/tag1/tag2", "text"} to "&lt;tag1&gt;&lt;tag2&gt;text&lt;/tag2&gt;&lt;/tag1&gt;". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>pointer to root element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>textual representation of XML path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>text element to append to path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga568ec520d4ecebc8e60540a17888fc0d" name="ga568ec520d4ecebc8e60540a17888fc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568ec520d4ecebc8e60540a17888fc0d">&#9670;&#160;</a></span>CreatePaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLElement * CreatePaths </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLDocument &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create multiple XML trees inside <code>tynyxml2</code> XML document. Invokes CreatePath multiple times passing {path, text} value at each invocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>root element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>XML path in "/.../..." format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>list of {path, text element value} to pass to CreatePath </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML tree </dd></dl>

</div>
</div>
<a id="gaceed1c630628211fe28e59763878d374" name="gaceed1c630628211fe28e59763878d374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceed1c630628211fe28e59763878d374">&#9670;&#160;</a></span>CreatePaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLElement * CreatePaths </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create multiple XML trees under element. Invokes CreatePath multiple times passing {path, text} value at each invocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>root element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>XML path in "/.../..." format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paths</td><td>list of {path, text element value} to pass to CreatePath </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML tree </dd></dl>

</div>
</div>
<a id="gacaf7799880288a51a684f1f3947146a4" name="gacaf7799880288a51a684f1f3947146a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaf7799880288a51a684f1f3947146a4">&#9670;&#160;</a></span>DOMToDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; DOMToDict </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert XML text to {path, text element array} map. <b>Input</b>. </p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">tag1</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">tag2</span>&gt;</div>
<div class="line">    <span class="keyword">Text</span> 1<span class="keyword">_2</span></div>
<div class="line">  &lt;/<span class="keywordtype">tag2</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">tag2</span>&gt;</div>
<div class="line">    <span class="keyword">Text</span> 2<span class="keyword">_2</span></div>
<div class="line">  &lt;/<span class="keywordtype">tag2</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">othertag</span>&gt;</div>
<div class="line">    <span class="keyword">Other</span> <span class="keyword">text</span></div>
<div class="line">  &lt;/<span class="keywordtype">othertag</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">tag1</span>&gt;</div>
</div><!-- fragment --><p><b>Output</b> </p><div class="fragment"><div class="line">unordered_map&lt;string, string&gt; domMap = {</div>
<div class="line">  {<span class="stringliteral">&quot;/tag1/tag2&quot;</span>, {<span class="stringliteral">&quot;Text 1_2&quot;</span>, <span class="stringliteral">&quot;Text 2_2&quot;</span>},</div>
<div class="line">  {<span class="stringliteral">&quot;/tag1/othertag&quot;</span>, {<span class="stringliteral">&quot;Other text&quot;</span>}}</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of {path, element array} where the key is the path to the text elements stored in the value </dd></dl>

</div>
</div>
<a id="gae82f61f7f4a30fb27a566a889fb3abc7" name="gae82f61f7f4a30fb27a566a889fb3abc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae82f61f7f4a30fb27a566a889fb3abc7">&#9670;&#160;</a></span>ExtractSubPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; ExtractSubPaths </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>domMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return map of {subpaths with same prefix, {list of text elements under subpaths}}. </p>
<p><b>Input</b> </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> path = <span class="stringliteral">&quot;/path/to/some&quot;</span></div>
<div class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; domMapInput = {</div>
<div class="line">  {<span class="stringliteral">&quot;/path/to/some/textA&quot;</span>, {<span class="stringliteral">&quot;text A1&quot;</span>, <span class="stringliteral">&quot;text A2&quot;</span>}},</div>
<div class="line">  {<span class="stringliteral">&quot;/path/to/some_other/text&quot;</span>, {<span class="stringliteral">&quot;other text&quot;</span>}},</div>
<div class="line">  {<span class="stringliteral">&quot;/path/to/some/textB&quot;</span>, {<span class="stringliteral">&quot;text B1&quot;</span>, <span class="stringliteral">&quot;text B2&quot;</span>, <span class="stringliteral">&quot;text B3&quot;</span>}}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> subPaths = <a class="code hl_function" href="group__Parsing.html#gae82f61f7f4a30fb27a566a889fb3abc7">ExtractSubPaths</a>(path, domMapInput);</div>
<div class="ttc" id="agroup__Parsing_html_gae82f61f7f4a30fb27a566a889fb3abc7"><div class="ttname"><a href="group__Parsing.html#gae82f61f7f4a30fb27a566a889fb3abc7">ExtractSubPaths</a></div><div class="ttdeci">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; ExtractSubPaths(const std::string &amp;prefix, const std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; &amp;domMap)</div><div class="ttdoc">Return map of {subpaths with same prefix, {list of text elements under subpaths}}.</div></div>
</div><!-- fragment --><p> <b>Output</b> </p><div class="fragment"><div class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; subPaths = {</div>
<div class="line">  {<span class="stringliteral">&quot;/textA&quot;</span>, {<span class="stringliteral">&quot;text A1&quot;</span>, <span class="stringliteral">&quot;text A2&quot;</span>}},</div>
<div class="line">  {<span class="stringliteral">&quot;/textB&quot;</span>, {<span class="stringliteral">&quot;text B1&quot;</span>, <span class="stringliteral">&quot;text B2&quot;</span>}}</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>XML prefix in path format: "/.../..." </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domMap</td><td>DOM document in {prefix =&gt; text value} format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of subpaths =&gt; text element list having prefix <code>prefix</code> </dd></dl>

</div>
</div>
<a id="ga663d4f6452842fce3694964ec0d38bd1" name="ga663d4f6452842fce3694964ec0d38bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga663d4f6452842fce3694964ec0d38bd1">&#9670;&#160;</a></span>FindElementText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FindElementText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return text inside XML tags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>name of XML tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML text element. </dd></dl>

</div>
</div>
<a id="ga8a75f823e8de2f3d1b501bab6b6510f5" name="ga8a75f823e8de2f3d1b501bab6b6510f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a75f823e8de2f3d1b501bab6b6510f5">&#9670;&#160;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Get </td>
          <td>(</td>
          <td class="paramtype">const XMLRecord &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract string from map </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>XMLRecord instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>XMLRecord </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>key in the form "/tag1/tag11..." </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>text or empty string if text not found or empty </dd></dl>

</div>
</div>
<a id="ga020103649cb1ae997e00f10d72ad6acd" name="ga020103649cb1ae997e00f10d72ad6acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020103649cb1ae997e00f10d72ad6acd">&#9670;&#160;</a></span>HTTPHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sss::HTTPHeader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return HTTP header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">headers</td><td>text containing the header section of an HTTP payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>header name </td></tr>
  </table>
  </dd>
</dl>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Parsing_ga020103649cb1ae997e00f10d72ad6acd_icgraph.svg" width="346" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaca9233a3e8a097605d9168bf860e93e5" name="gaca9233a3e8a097605d9168bf860e93e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca9233a3e8a097605d9168bf860e93e5">&#9670;&#160;</a></span>HTTPHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Types.html#ga715f63ab4ed0dae42d3337ff0a29d5d3">Headers</a> sss::HTTPHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>headers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return HTTP headers as key-value pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">headers</td><td>text containing the header section of an HTTP payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::map&lt;std::string, std::string&gt;</code> of {header name, header value} tuples </dd></dl>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Parsing_gaca9233a3e8a097605d9168bf860e93e5_icgraph.svg" width="643" height="200"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga95e0b5f396ca92caa59f6870807789b6" name="ga95e0b5f396ca92caa59f6870807789b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e0b5f396ca92caa59f6870807789b6">&#9670;&#160;</a></span>MetaDataHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Types.html#ga769a4a4cc1bcab19498096e1b85e7e69">MetaDataMap</a> sss::MetaDataHeaders </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>headers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return <code>x-amz-meta-*</code> headers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">headers</td><td>text containing the header section of an HTTP payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::map&lt;std::string, std::string&gt;</code> of {header name, header value} tuples </dd></dl>

</div>
</div>
<a id="ga5ffdbf75ebbc4755e1ded379546865d5" name="ga5ffdbf75ebbc4755e1ded379546865d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffdbf75ebbc4755e1ded379546865d5">&#9670;&#160;</a></span>ParseXMLMultiPathText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; ParseXMLMultiPathText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefixPpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffixPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multilevel parsing function: return all elements matching path under prefix. </p>
<p>E.g.</p>
<p>If prefix is "/tag1/tag11" and suffix is "/name" it will extract text from <b>all</b> the &lt;name&gt;Name one&lt;/name&gt;&lt;name&gt;Name two&lt;/name&gt; elements inside <code></code> &lt;tag1&gt;&lt;tag2&gt;..&lt;/tag2&gt;&lt;/tag1 equivalent to:</p>
<p>It groups text elements by XML prefix, mapping prefix to multiple text elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixPath</td><td>starting path from element extraction.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffixPath</td><td>return all text elements matching suffixPath path under <code>prefixPath</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of extracted text elements under <code>/prefixPath/suffixPath/</code> </dd></dl>

</div>
</div>
<a id="gacf271316bde50a40dba0a85b94fe0f00" name="gacf271316bde50a40dba0a85b94fe0f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf271316bde50a40dba0a85b94fe0f00">&#9670;&#160;</a></span>ParseXMLPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParseXMLPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract text under XML path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">XML</td><td>text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to XML tag in the format "/tag1/tag11/tag112...". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML text element. </dd></dl>

</div>
</div>
<a id="ga71fc992a1e6c4c8a220fd916e08acb79" name="ga71fc992a1e6c4c8a220fd916e08acb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71fc992a1e6c4c8a220fd916e08acb79">&#9670;&#160;</a></span>ParseXMLPathElementsText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; ParseXMLPathElementsText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all elements at location grouped by element name. </p>
<p><b>Input</b> </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">tag1</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">tag11</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">node1</span>&gt;</div>
<div class="line">      <span class="keyword">Text1</span></div>
<div class="line">    &lt;/<span class="keywordtype">node1</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">node1</span>&gt;</div>
<div class="line">      <span class="keyword">Text1_2</span></div>
<div class="line">    &lt;/<span class="keywordtype">node1</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">node2</span>&gt;</div>
<div class="line">      <span class="keyword">Text2</span></div>
<div class="line">    &lt;/<span class="keywordtype">node2</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">node2</span>&gt;</div>
<div class="line">      <span class="keyword">Text2_2</span></div>
<div class="line">    &lt;/<span class="keywordtype">node2</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">tag11</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">tag1</span>&gt;</div>
</div><!-- fragment --><p><b>Output</b> </p><div class="fragment"><div class="line">unordered_map&lt;string, vector&lt;string&gt;&gt; elementsMap = {</div>
<div class="line">  {<span class="stringliteral">&quot;node1&quot;</span>, {<span class="stringliteral">&quot;Text1&quot;</span>, <span class="stringliteral">&quot;Text1_2&quot;</span>}},</div>
<div class="line">  {<span class="stringliteral">&quot;node2&quot;</span>, {<span class="stringliteral">&quot;Text2&quot;</span>, <span class="stringliteral">&quot;Text2_2&quot;</span>}}</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path to elements: <code>"/tag1/tag12/...."</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element text at path grouped by element name </dd></dl>

</div>
</div>
<a id="ga010b2c94ea150c9c57b9a42cc03ba414" name="ga010b2c94ea150c9c57b9a42cc03ba414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga010b2c94ea150c9c57b9a42cc03ba414">&#9670;&#160;</a></span>RecordList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unordered_map&lt; std::string, std::string &gt; &gt; RecordList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>domMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract records from DOM Map. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Parsing.html#gacaf7799880288a51a684f1f3947146a4" title="Convert XML text to {path, text element array} map. Input.">DOMToDict</a>. A record is defined as a map with:<ul>
<li>key = path to tag element containing text element in the format "/tag1/tag2/..."</li>
<li>value = text element under <em>key</em> path</li>
</ul>
</dd></dl>
<p><b>Input:</b> </p><ul>
<li><b><code>domMap</code> =</b> XML text -&gt; DOMToDict -&gt; {"/listbucketresult/contents/key", "Key1"}...</li>
<li><b><code>prefixPath</code> =</b> "/listbucketresult/contents"</li>
</ul>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div>
<div class="line">&lt;ListBucketResult</div>
<div class="line">   xmlns=<span class="stringliteral">&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;</span>&gt;</div>
<div class="line">   &lt;Name&gt;tst&lt;/Name&gt;</div>
<div class="line">   &lt;Prefix&gt;&lt;/Prefix&gt;</div>
<div class="line">   &lt;MaxKeys&gt;1000&lt;/MaxKeys&gt;</div>
<div class="line">   &lt;IsTruncated&gt;<span class="keyword">false</span>&lt;/IsTruncated&gt;</div>
<div class="line">   &lt;Contents&gt;</div>
<div class="line">       &lt;Key&gt;Key1&lt;/Key1&gt;</div>
<div class="line">       &lt;Size&gt;67108864&lt;/Size&gt;</div>
<div class="line">       &lt;StorageClass&gt;STANDARD&lt;/StorageClass&gt;</div>
<div class="line">       &lt;Owner&gt;</div>
<div class="line">           &lt;ID&gt;Owner1&lt;/ID&gt;</div>
<div class="line">           &lt;DisplayName&gt;Owner One&lt;/DisplayName&gt;</div>
<div class="line">       &lt;/Owner&gt;</div>
<div class="line">       &lt;Type&gt;Normal&lt;/Type&gt;</div>
<div class="line">   &lt;/Contents&gt;</div>
<div class="line">   &lt;Contents&gt;</div>
<div class="line">       &lt;Key&gt;Key2&lt;/Key&gt;</div>
<div class="line">       &lt;Size&gt;4294967296&lt;/Size&gt;</div>
<div class="line">       &lt;StorageClass&gt;STANDARD&lt;/StorageClass&gt;</div>
<div class="line">       &lt;Owner&gt;</div>
<div class="line">           &lt;ID&gt;Owner1&lt;/ID&gt;</div>
<div class="line">           &lt;DisplayName&gt;Owner One&lt;/DisplayName&gt;</div>
<div class="line">       &lt;/Owner&gt;</div>
<div class="line">       &lt;Type&gt;Normal&lt;/Type&gt;</div>
<div class="line">   &lt;/Contents&gt;</div>
<div class="line">&lt;/ListBucketResult&gt;</div>
</div><!-- fragment --><p><b>Output</b> </p>
<p>If the case insensitive flag is set (default) then all tag names are converted to lowercase.</p>
<div class="fragment"><div class="line">vector&lt;unordered_map&lt;string, string&gt;&gt; record = {</div>
<div class="line">    {</div>
<div class="line">      {<span class="stringliteral">&quot;/key&quot;</span>, <span class="stringliteral">&quot;Key1&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/size&quot;</span>,<span class="stringliteral">&quot;67108864&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/storageclass&quot;</span>, <span class="stringliteral">&quot;STANDARD&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/owner/ID&quot;</span>, <span class="stringliteral">&quot;Owner1&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/owner/displayname&quot;</span>, <span class="stringliteral">&quot;Owner One&quot;</span>}</div>
<div class="line">      {<span class="stringliteral">&quot;/type&quot;</span>, <span class="stringliteral">&quot;Normal&quot;</span>}</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      {<span class="stringliteral">&quot;/key&quot;</span>, <span class="stringliteral">&quot;Key2&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/size&quot;</span>,<span class="stringliteral">&quot;4294967296&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/storageclass&quot;</span>, <span class="stringliteral">&quot;STANDARD&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/owner/ID&quot;</span>, <span class="stringliteral">&quot;Owner1&quot;</span>},</div>
<div class="line">      {<span class="stringliteral">&quot;/owner/displayname&quot;</span>, <span class="stringliteral">&quot;Owner One&quot;</span>}</div>
<div class="line">      {<span class="stringliteral">&quot;/type&quot;</span>, <span class="stringliteral">&quot;Normal&quot;</span>}</div>
<div class="line">    }</div>
<div class="line">  };</div>
</div><!-- fragment --><p>Transpose operation:</p>
<p>FROM: </p><div class="fragment"><div class="line">/bucket/creation/date  date1</div>
<div class="line">                       date2</div>
<div class="line">                       date3</div>
<div class="line">/bucket/name   name1</div>
<div class="line">               name2</div>
</div><!-- fragment --><p>TO: </p><div class="fragment"><div class="line">/bucket/creation/date  date1</div>
<div class="line">/bucket/name           name1</div>
<div class="line"> </div>
<div class="line">/bucket/creation/date  date2</div>
<div class="line">/bucket/name           name2</div>
<div class="line"> </div>
<div class="line">/bucket/creation/date  date3</div>
<div class="line">/bucket/name           <span class="stringliteral">&quot;&quot;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>XML path to record data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domMap</td><td>XML document transformed into {"path", "text"} map through DOMToDict function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of record maps, each map contains the {field name, field value} entries for one record. </dd></dl>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Parsing_ga010b2c94ea150c9c57b9a42cc03ba414_icgraph.svg" width="300" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gab31b67eec4fc7c00367031debd298fd8" name="gab31b67eec4fc7c00367031debd298fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab31b67eec4fc7c00367031debd298fd8">&#9670;&#160;</a></span>TrimETag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sss::TrimETag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>etag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract ETag string from returned etag text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">etag</td><td>etag text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>etag string without quotes </dd></dl>

</div>
</div>
<a id="gacf486071ed8bd3e6f76fe9ee23639bde" name="gacf486071ed8bd3e6f76fe9ee23639bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf486071ed8bd3e6f76fe9ee23639bde">&#9670;&#160;</a></span>XMLTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sss::XMLTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return content of XML tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td><code></code> &lt;tag&gt; name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code></code> &lt;tag&gt; content </dd></dl>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Parsing_gacf486071ed8bd3e6f76fe9ee23639bde_icgraph.svg" width="364" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaddaff0aa8a7f3ad2e60f73e16fc3ce11" name="gaddaff0aa8a7f3ad2e60f73e16fc3ce11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddaff0aa8a7f3ad2e60f73e16fc3ce11">&#9670;&#160;</a></span>XMLTagPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sss::XMLTagPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return content of XML tag matching hierchical path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><code>tag</code> path separated by <code>'/'</code> character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>content of tag if found, empty string otherwise </dd></dl>

</div>
</div>
<a id="gabb6c22034ff7357c481d51660b33df17" name="gabb6c22034ff7357c481d51660b33df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb6c22034ff7357c481d51660b33df17">&#9670;&#160;</a></span>XMLTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; sss::XMLTags </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and return content of all XML tags matching word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xml</td><td>XML text </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td><code></code> &lt;tag&gt; name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>content</code> of each tag matching name </dd></dl>

</div>
</div>
<a id="ga85c224486b4f631683d4f6bc22a54620" name="ga85c224486b4f631683d4f6bc22a54620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c224486b4f631683d4f6bc22a54620">&#9670;&#160;</a></span>XMLToText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string XMLToText </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLDocument &amp;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>header</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>eol_</em> = <code>'\n'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt;&#160;</td>
          <td class="paramname"><em>kv</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform DOM into text, replacing matching keywords with values specified in {keyword =&gt; value} map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doc</td><td>XML document in <code>tinyxml2</code> format</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kv</td><td>keyword =&gt; value map, keywords are replaced with values in translated text</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>if <code>true</code> addx the <code>&lt;xml</code>...&gt; header</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eol</td><td>end of line separator, default is '<br  />
', if '0' no EOL generated</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indent</td><td>indentation value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XML text with keywords replaced with values specified in input map </dd></dl>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__Parsing_ga85c224486b4f631683d4f6bc22a54620_icgraph.svg" width="307" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
